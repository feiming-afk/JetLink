# JetLink V2.0 - 项目思路与技术解析

本文档旨在深入剖析 JetLink V2.0 的架构设计、关键技术实现和未来的优化方向，为后续的维护和迭代提供参考。

---

## 1. 架构设计 (Architecture)

项目严格遵循 **MVVM (Model-View-ViewModel)** 架构，并结合 **Repository 模式** 和**单一数据源 (SSOT)** 策略，构建了一个可扩展、可维护的数据流和业务逻辑分离的结构。

#### 1.1 MVVM 职责划分

-   **View (Compose UI)**: `ChatScreen.kt`, `ChatBubble.kt` 等。完全的声明式 UI，只负责观察 `ViewModel` 暴露的 `StateFlow` 并将 UI 事件（如点击、输入）传递给 `ViewModel`。UI 层本身不包含任何业务逻辑。
-   **ViewModel (`ChatViewModel.kt`)**: 作为 UI 的状态持有者和业务逻辑处理器。它从 `Repository` 获取数据流，处理 UI 事件（如 `sendMessage`），并管理 UI 相关的状态，例如“正在回复”、“对方正在输入”等。
-   **Model (Data Layer)**: 由 `ChatRepository`, `Room Database` (`ChatDao`, `MessageEntity`) 和 `SocketClientManager` 组成。`Repository` 封装了所有的数据操作，无论是从本地数据库读取还是通过网络发送。

#### 1.2 单一数据源 (SSOT) 与响应式数据流

JetLink 的核心设计思想是**数据库作为单一数据源**。这意味着 UI (View) 从不直接与网络层交互，它只信任数据库中的数据。

**数据流向图:**
```
[Socket] --(接收 JSON)--> [Repository] --(保存)--> [Room]
   ^                                                   |
   | (发送 JSON)                                       | (Flow<T>)
   |                                                   v
[Compose UI] <-- (观察 StateFlow) -- [ViewModel] <-- (观察) -- [Room]
   |                                                   ^
   | (点击发送)                                        | (插入)
   '------------> [ViewModel] ------> [Repository] ----'
```

-   **接收消息**: `SocketClientManager` 监听到新消息后，通知 `ChatRepository`。`Repository` 负责将消息解析并存入 `Room` 数据库。由于 `ViewModel`正在通过 `Flow` 观察数据库，这一插入操作会自动触发 `ViewModel` 的 `StateFlow` 更新，进而驱动 `Compose UI` 重组，显示新消息。
-   **发送消息**: 用户在 `Compose UI` 点击发送后，`ViewModel` 调用 `Repository` 的 `sendMessage` 方法。`Repository` **首先**将消息存入 `Room`（触发 UI 立即显示“我”发送的消息），**然后**通过 `SocketClientManager` 将消息发送到网络。

这个模型确保了 UI 的**即时响应**和**数据一致性**，即使用户在离线状态下发送消息，消息也能先显示在界面上。

---

## 2. 项目代码结构 (Project Structure)

```
com.example.jetlink
├── data                  # 数据层：数据库、实体、数据仓库
│   ├── dao
│   │   └── ChatDao.kt        # Room 数据库访问接口
│   ├── entity
│   │   ├── MessageEntity.kt  # 消息数据表实体
│   │   └── UserEntity.kt     # 用户数据表实体
│   ├── repository
│   │   └── ChatRepository.kt # 数据仓库，封装数据来源
│   └── AppDatabase.kt      # Room数据库定义
├── model                 # 网络数据模型 (DTO)
│   ├── MessagePayload.kt   # Socket消息载荷
│   └── SocketMessage.kt    # Socket消息模型
├── socket                # 网络通信层
│   ├── SocketClientManager.kt # 客户端Socket管理
│   └── SocketServer.kt        # (简易)服务端Socket实现
├── ui                    # UI层：屏幕、组件、主题
│   ├── components          # 可复用的Compose组件
│   │   ├── ChatBubble.kt
│   │   └── ChatInputBar.kt
│   ├── screens             # 应用的各个屏幕
│   │   ├── ChatScreen.kt
│   │   ├── ConversationListScreen.kt
│   │   └── ProfileScreen.kt
│   └── theme               # 主题和样式
│       ├── Color.kt
│       ├── Theme.kt
│       └── Type.kt
├── util                  # 通用工具类
│   ├── ImageUtils.kt       # 图片压缩和转换工具
│   └── NotificationHelper.kt # 系统通知工具
└── viewmodel             # ViewModel层
    └── ChatViewModel.kt      # 聊天页面的ViewModel
```

---

## 3. 关键技术难点与解决方案

#### 3.1 Socket 通信协议

我们设计了一套基于 JSON 的、可扩展的文本协议来承载所有实时通信。

-   **核心字段**: `type` 字段是协议的核心，用于区分不同的指令，如 `MSG` (发送消息) 和 `TYPING` (正在输入状态)。
-   **载荷设计**: `payload` 对象用于携带具体业务数据。例如，发送图片时，`payload` 包含了 `contentType: "IMAGE"` 和 `content: "Base64String..."`。这种设计使得未来扩展新消息类型（如语音、文件）变得容易，只需定义新的 `contentType` 即可。

#### 3.2 图片传输优化

在 IM 中直接通过 Socket 传输大文件是低效且不稳定的。我们采用了一种适合局域网小到中等图片传输的方案：

1.  **压缩**: 在发送前，使用 `ImageUtils.compressImageToBase64` 将图片尺寸限制在 `1024px` 以内，并使用 `JPEG` 格式进行有损压缩，大幅减小体积。
2.  **Base64 编码**: 将压缩后的图片二进制数据转换为 Base64 字符串，使其可以安全地嵌入到 JSON 文本协议中进行传输。
3.  **本地缓存优先**: 为了解决 Android 的 `content://` URI 访问权限问题并提升加载性能，发送图片时会先将其**复制到应用内部缓存目录**，生成一个稳定的 `file://` URI。数据库中存储的是这个内部 URI，确保 `Coil` 任何时候都能访问和加载。

#### 3.3 性能优化 (Code Review Highlights)

在开发后期，我们针对性能和代码质量进行了关键优化：

-   **O(1) 引用消息查找**:
    -   **问题**: 在 `LazyColumn` 中渲染引用回复时，最初使用 `messages.find { it.msgId == replyId }` 来查找被引用的消息。这是一个 **O(n)** 操作，当聊天记录很长时，每次滚动都会触发大量计算，导致 UI 卡顿。
    -   **解决方案**: 在 `ChatViewModel` 中，我们创建了一个派生自 `messages` 列表的 `StateFlow<Map<Long, MessageEntity>>`。这个 `messageMap` 将消息 `msgId` 作为键，`MessageEntity` 作为值。它只在 `messages` 列表更新时计算一次。UI 层可以直接通过 `messageMap[replyId]` 以 **O(1)** 的时间复杂度获取被引用的消息，彻底解决了滚动性能问题。

-   **线程与协程治理**:
    -   **问题**: `NetworkOnMainThreadException` 崩溃，因为网络请求在主线程被调用。
    -   **解决方案**: 重构了 `ChatRepository` 的 `sendMessage` 方法，使用 `withContext(Dispatchers.IO)` 将整个方法体（包括文件操作和网络发送）包裹起来，强制所有耗时操作都在 IO 线程执行。同时，`SocketClientManager` 的 `sendMessage` 也被改造为 `suspend` 函数，将线程管理的责任统一交给了调用方 `Repository`，使得职责更清晰。

-   **键盘布局问题**:
    -   **问题**: 在涉及表情面板和键盘切换时，`imePadding()` 与 `Scaffold` 的 `bottomBar` 交互复杂，导致键盘上方或下方出现异常空白。
    -   **解决方案**: 放弃使用 `Scaffold` 的 `bottomBar`。改为在 `Scaffold` 的 `content` 区域使用一个 `Column` 包含 `LazyColumn` (`weight(1f)`) 和 `ChatInputBar`。然后对 `ChatInputBar` 应用 `.windowInsetsPadding(WindowInsets.ime.union(WindowInsets.navigationBars))`。这种方式利用 `union` 智能合并键盘和导航栏的高度（取最大值），彻底解决了各种场景下的布局空白问题，是处理此类界面的最佳实践。

---

## 4. 后期优化思路 (Future Improvements)

-   **安全性**: 当前所有通信都是明文的，非常不安全。未来应引入 **TLS/SSL** (`SSLSocket`) 对通信通道进行加密，防止中间人攻击。
-   **传输效率**: 对于大文件或视频，Base64 编码会增加约 33% 的体积。更好的方案是：
    1.  `Socket` 只作为**信令通道**，用于交换消息、状态和文件元数据。
    2.  在 App 内集成一个轻量级的 **HTTP Server** (如 Ktor, NanoHTTPD)。
    3.  发送文件时，上传到发送方的 HTTP Server，然后通过 Socket 将文件的下载 URL 发送给对方。接收方通过 HTTP 下载文件。
-   **功能扩展**:
    -   **群聊**: 需要修改 `sessionId` 的定义，并要求服务端维护一个会话与成员的映射关系，实现消息的多路广播。
    -   **音视频通话**: 集成 **WebRTC**，`Socket` 可用于交换 `SDP` 和 `ICE Candidate` 等信令。
